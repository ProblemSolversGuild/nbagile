# AUTOGENERATED! DO NOT EDIT! File to edit: 00_docstring.ipynb (unless otherwise specified).


from __future__ import annotations


__all__ = ['get_annotations', 'apply', 'reformat_function', 'reformat_class']

# Cell
import inspect, ast, astunparse
#nbdev_comment from __future__ import annotations
import fastcore.docments as dments
from collections import OrderedDict

from fastcore.basics import risinstance
from fastcore.dispatch import retain_type
from fastcore.xtras import is_listy

# Cell
def get_annotations(
    source:str # Source code of function or class
):
    "Extracts the type annotations from source code"
    parse = ast.parse(source)
    arg_annos = []
    for i,anno in enumerate(parse.body[0].args.args):
        if anno.annotation is not None:
            arg_annos.append(astunparse.unparse(anno.annotation).strip('\n'))
        else:
            arg_annos.append(anno.annotation)
        parse.body[0].args.args[i].annotation = None
    if parse.body[0].returns is not None:
        ret_anno = astunparse.unparse(parse.body[0].returns).strip('\n')
    else:
        ret_anno = None
    return arg_annos, ret_anno

# Cell
def _get_leading(o):
    return len(o) - len(o.lstrip(o[0])), o[0]

# Cell
def apply(
    func:callable, # A callable function
    x:any, # Something to apply `func` on
    *args, # Arguments for func
    **kwargs # Kwargs for func
):
    "Apply `func` recursively to `x`, passing on args. Originally from fastai.torch_core"
    if is_listy(x): return type(x)([apply(func, o, *args, **kwargs) for o in x])
    if isinstance(x,dict):  return {k: apply(func, v, *args, **kwargs) for k,v in x.items()}
    res = func(x, *args, **kwargs)
    return res if x is None else retain_type(res, x)

# Cell
def reformat_function(
    source:str, # Source code
):
    "Takes messy source code and refactors it into a readable PEP-8 standard style"
    # Read in docments, parse source code, generate annotations
    docs = dments.docments(source)
    parsed_source = ast.parse(source)
    annos = get_annotations(source)

    # Set all arg annotations to None
    _ = apply(lambda x: setattr(x, 'annotation', None), parsed_source.body[0].args.args)

    parsed_source.body[0].returns = None
    body = parsed_source.body[0].body
    unparsed_source = astunparse.unparse(parsed_source).lstrip('\n').split('\n')
    has_decorator = len(parsed_source.body[0].decorator_list) > 0

    # Extract function definition
    function_definition = '\n'.join(unparsed_source[:2]) if has_decorator else unparsed_source[0]

    # Check if we have a docstring and extract function innards
    def _extract_innards(is_str:bool):
        i = 2 if is_str else 1
        return '\n'.join(unparsed_source[i+1:]) if has_decorator else '\n'.join(unparsed_source[i:])

    function_innards = _extract_innards(isinstance(body[0].value, ast.Str))

    def _get_whitespace(): return whitespace_char*num_whitespace

    if unparsed_source[2] != '':
        num_whitespace, whitespace_char = _get_leading(unparsed_source[2])
    else:
        if len(unparsed_source) < 4:
            num_whitespace, whitespace_char = _get_leading(unparsed_source[1])
        else:
            num_whitespace, whitespace_char = _get_leading(unparsed_source[3])

    docstring = f'\n{_get_whitespace()}"""'

    if isinstance(body[0].value, ast.Str):
        _quotes = ("'", '"')
        orig_docstring = astunparse.unparse(body[0]).lstrip(whitespace_char).replace(_quotes[0],'').replace(_quotes[1],'')
        orig_docstring = orig_docstring.split('\\n')
        def _inner(line, whitespace_char):
            diff = len(line) - len(line.lstrip())
            whitespace = whitespace_char * diff if diff > 0 else _get_whitespace()
            return f'\n{whitespace}{line}'

        o = apply(_inner, orig_docstring, whitespace_char=whitespace_char)
        o[0] = orig_docstring[0].lstrip()
        docstring +=  '\n'.join(o)

    param_string = f'\n{_get_whitespace()}Parameters\n{_get_whitespace()}----------\n'
    if len(docs.keys()) >= 1:
        param_string = f'\n{_get_whitespace()}Parameters\n{_get_whitespace()}----------\n'
        for i, param in enumerate(docs.keys()):
            if param != "return" and param != "self" and param != "cls":
                param_string += f'{_get_whitespace()}{param}'
                if annos[0][i] is not None:
                    param_string += f' : {annos[0][i]}'
                else:
                    param_string += f' : any'
                param_string += '\n'
                if docs[param] is not None:
                    param_string += f'{whitespace_char * (num_whitespace+2)}{docs[param]}\n'
    if param_string != f'\n{_get_whitespace()}Parameters\n{_get_whitespace()}----------\n':
        docstring += param_string

    if (annos[-1] != inspect._empty) and ('return' in docs.keys()):
        docstring += f'\n{_get_whitespace()}Returns\n'
        docstring += f'{_get_whitespace()}-------\n'
        docstring += f'{_get_whitespace()}{annos[1]}\n'
        docstring += f'{whitespace_char * (num_whitespace+2)}{docs["return"]}\n'
    docstring += f'{_get_whitespace()}"""\n'
    return f'{function_definition}{docstring}{function_innards}'

# Cell
def reformat_class(
    source:str, # Source code of a full class
    recursion_level:int = 1, # Depth of recursion
):
    "Takes messy class code and refactors it into a readable PEP-8 standard style"
    whitespace_char = None
    def _format_spacing(code, num_leading):
        code = [c for c in code if len(c) > 0]
        def _inner(c, num_leading):
            curr_leading = len(c) - len(c.lstrip())
            return f'{c[0] * (curr_leading - num_leading)}{c.lstrip()}'
        return apply(_inner, code, num_leading=num_leading)
    # Parse source code and get body
    parsed_source = ast.parse(source)
    body = parsed_source.body[0].body
    new_source = ''

    unparsed_source = astunparse.unparse(parsed_source).lstrip('\n').split('\n')

    # Add function definition
    new_source += unparsed_source[0]

    def _get_whitespace(): return whitespace_char * num_whitespace

    num_whitespace, whitespace_char = _get_leading(unparsed_source[2])

    docstring = f'\n{_get_whitespace()}"""'
    docstring_len, diff = 0,2

    new_nodes = [unparsed_source[0]]

    for i, node in enumerate(body):
        if risinstance((ast.ClassDef, ast.FunctionDef), node):
            beginning_lineno = node.lineno
            split_code = source.split('\n')
            if i < (len(body) - 1):
                ending_lineno = body[i+1].lineno
                code = split_code[beginning_lineno-1:ending_lineno-1]
                num_leading = len(code[0]) - len(code[0].lstrip())
                if isinstance(node, ast.ClassDef):
                    for i,c in enumerate(code): code[i] = code[i][num_leading:]
                    new_nodes.append(reformat_class('\n'.join(code), recursion_level+1))
                else:
                    if whitespace_char is None:
                        whitespace_char = code[i][0]
                    code = _format_spacing(code, num_leading)
                    new_nodes.append(reformat_function('\n'.join(code)))
            else:
                code = split_code[beginning_lineno-1:]
                if whitespace_char is None:
                    whitespace_char = code[i][0]
                num_leading = len(code[0]) - len(code[0].lstrip())
                code = _format_spacing(code, num_leading)
                new_nodes.append(reformat_function('\n'.join(code)))
        else:
            if isinstance(body[0].value, ast.Str) and i == 0:
                _quotes = ("'", '"')
                orig_docstring = astunparse.unparse(body[0]).lstrip(whitespace_char).replace(_quotes[0],'').replace(_quotes[1],'')
                orig_docstring = orig_docstring.split('\\n')
                def _inner(line, whitespace_char):
                    diff = len(line) - len(line.lstrip())
                    whitespace = whitespace_char * diff if diff > 0 else _get_whitespace()
                    return f'\n{whitespace}{line}'

                o = apply(_inner, orig_docstring, whitespace_char=whitespace_char)
                o[0] = orig_docstring[0].lstrip()
                docstring +=  '\n'.join(o)
                docstring += f'\n{_get_whitespace()}"""'
                full_string = docstring.split('\n')
                new_string = ''

                if len(full_string) == 4:
                    new_string = apply(lambda x: x.lstrip(), full_string)
                    new_string = ''.join(new_string)
                else:
                    new_string = '\n'.join(full_string)
                docstring_len = len(new_string.split('\n'))
                new_nodes.append(new_string)
            else:
                new_nodes.append(f'{astunparse.unparse(node).strip()}')
    formatted_source = []
    num_chars = 4
    if recursion_level > 1:
        num_chars += (2*(recursion_level-1)) - 2

    formatted_source.append(new_nodes[0])
    line = new_nodes[1]
    if not len(line.lstrip()) < len(line):
        line = line.split('\n')
        line = apply(lambda x: f'{whitespace_char * num_chars}{x}', line)
        line = '\n'.join(line)
    formatted_source.append(line.lstrip('\n'))

    for i,line in enumerate(new_nodes[2:]):
        l = line.split('\n')
        for i,o in enumerate(l):
            l[i] = f'{whitespace_char * num_chars}{o}'
        line = '\n'.join(l)
        formatted_source.append(line)
    return '\n'.join(formatted_source)